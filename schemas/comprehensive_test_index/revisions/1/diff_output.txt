Diff between current revision comprehensive_test_index/revisions/1 and empty baseline

=== Settings Diff ===
=== Changes Detected ===

➕ ADDED: index
  New value:
    {
      "replication": {
        "type": "DOCUMENT"
      },
      "number_of_shards": "1",
      "number_of_replicas": "1"
    }

=== Mappings Diff ===
=== Changes Detected ===

➕ ADDED: properties
  New value:
    {
      "alias_field": {
        "type": "alias",
        "path": "real_field"
      },
      "attachment": {
        "type": "binary"
      },
      "byte_field": {
        "type": "byte"
      },
      "completion_field": {
        "type": "completion",
        "analyzer": "simple",
        "preserve_separators": true,
        "preserve_position_increments": true,
        "max_input_length": 50
      },
      "constant_keyword_field": {
        "type": "constant_keyword",
        "value": "constant_value"
      },
      "date_nanos_field": {
        "type": "date_nanos"
      },
      "date_range_field": {
        "type": "date_range"
      },
      "description": {
        "type": "text",
        "analyzer": "english"
      },
      "double_range_field": {
        "type": "double_range"
      },
      "float_range_field": {
        "type": "float_range"
      },
      "geo_shape_field": {
        "type": "geo_shape"
      },
      "half_float_field": {
        "type": "half_float"
      },
      "integer_range_field": {
        "type": "integer_range"
      },
      "ip_address": {
        "type": "ip"
      },
      "ip_range_field": {
        "type": "ip_range"
      },
      "is_available": {
        "type": "boolean"
      },
      "keyword_with_normalizer": {
        "type": "keyword",
        "normalizer": "lowercase"
      },
      "location": {
        "type": "geo_point"
      },
      "long_range_field": {
        "type": "long_range"
      },
      "metadata": {
        "type": "object",
        "dynamic": "strict"
      },
      "multi_field_example": {
        "type": "text",
        "fields": {
          "english": {
            "type": "text",
            "analyzer": "english"
          },
          "raw": {
            "type": "keyword"
          }
        }
      },
      "nested_with_objects": {
        "type": "nested",
        "properties": {
          "inner_object": {
            "properties": {
              "inner_field": {
                "type": "text"
              }
            }
          }
        }
      },
      "object_with_dynamic": {
        "dynamic": "strict",
        "properties": {
          "nested_object": {
            "type": "object",
            "dynamic": "true"
          }
        }
      },
      "price": {
        "type": "float"
      },
      "product_id": {
        "type": "keyword",
        "doc_values": true
      },
      "product_name": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "quantity_in_stock": {
        "type": "integer"
      },
      "real_field": {
        "type": "keyword"
      },
      "release_date": {
        "type": "date",
        "format": "yyyy-MM-dd"
      },
      "reviews": {
        "type": "nested",
        "properties": {
          "comment": {
            "type": "text"
          },
          "rating": {
            "type": "short"
          },
          "review_date": {
            "type": "date"
          },
          "user_id": {
            "type": "keyword"
          }
        }
      },
      "scaled_float_field": {
        "type": "scaled_float",
        "scaling_factor": 100.0
      },
      "search_as_you_type": {
        "type": "search_as_you_type",
        "doc_values": false,
        "max_shingle_size": 3
      },
      "supplier_info": {
        "type": "object",
        "dynamic": "true",
        "properties": {
          "supplier_city": {
            "type": "text"
          },
          "supplier_name": {
            "type": "keyword"
          }
        }
      },
      "tags": {
        "type": "keyword"
      },
      "text_with_analyzer": {
        "type": "text",
        "analyzer": "standard",
        "search_analyzer": "english"
      },
      "token_count": {
        "type": "token_count",
        "analyzer": "standard"
      },
      "unsigned_long_field": {
        "type": "unsigned_long"
      },
      "wildcard_field": {
        "type": "wildcard",
        "doc_values": false
      }
    }

=== Painless Scripts Diff ===
➕ ADDED SCRIPT: upsert-document-8
  Content:
    1: if (ctx._source.containsKey('metadata') == false) {
    2:   ctx._source.metadata = new ArrayList();
    3: }
    4: 
    5: if (ctx._source.containsKey('access_controls') == false) {
    6:   ctx._source.access_controls = new ArrayList();
    7: }
    8: 
    9: if (ctx._source.containsKey('chunks') == false) {
    10:   ctx._source.chunks = new ArrayList();
    11: }
    12: 
    13: if (ctx._source.containsKey('tags') == false) {
    14:   ctx._source.tags = new ArrayList();
    15: }
    16: 
    17: ctx._source.resource_id = params.document.resource_id;
    18: ctx._source.resource_type = params.document.resource_type;
    19: ctx._source.organization_id = params.document.organization_id;
    20: if (params.document.updated_at != null) {
    21:   ctx._source.updated_at = params.document.updated_at;
    22: }
    23: 
    24: // Handle soft deletion by setting deleted_at if provided
    25: if (params.document.deleted_at != null) {
    26:   ctx._source.deleted_at = params.document.deleted_at;
    27: }
    28: 
    29: // Handle chunks updates
    30: if (params.document.chunks != null && params.document.chunks.size() > 0) {
    31:   ctx._source.chunks = params.document.chunks;
    32: }
    33: 
    34: // Handle chunks appending (for large document batching)
    35: if (params.document.append_chunks != null && params.document.append_chunks.size() > 0) {
    36:   for (chunk in params.document.append_chunks) {
    37:     ctx._source.chunks.add(chunk);
    38:   }
    39: }
    40: 
    41: // Handle explicit chunk removal
    42: if (params.document.remove_chunks != null && params.document.remove_chunks == true) {
    43:   ctx._source.chunks = new ArrayList();
    44: }
    45: 
    46: // Handle metadata updates
    47: if (params.document.metadata != null && params.document.metadata.size() > 0) {
    48:   Map existing = new HashMap();
    49:   for (int i = 0; i < ctx._source.metadata.size(); i++) {
    50:     existing.put(ctx._source.metadata[i].field_name, i);
    51:   }
    52: 
    53:   for (item in params.document.metadata) {
    54:     if (existing.containsKey(item.field_name)) {
    55:       ctx._source.metadata[existing.get(item.field_name)] = item;
    56:     } else {
    57:       ctx._source.metadata.add(item);
    58:     }
    59:   }
    60: }
    61: 
    62: // Handle explicit metadata removal
    63: if (params.document.remove_metadata != null && params.document.remove_metadata == true) {
    64:   ctx._source.metadata = new ArrayList();
    65: }
    66: 
    67: if (params.document.add_access_controls != null) {
    68:   for (access_control in params.document.add_access_controls) {
    69:     if (!ctx._source.access_controls.contains(access_control)) {
    70:       ctx._source.access_controls.add(access_control);
    71:     }
    72:   }
    73: }
    74: 
    75: if (params.document.remove_access_controls != null) {
    76:   ctx._source.access_controls.removeIf(access_control ->
    77:       params.document.remove_access_controls.contains(access_control));
    78: }
    79: 
    80: // Handle tags updates
    81: if (params.document.add_tags != null) {
    82:   // Create a map of existing tags by id for efficient lookup
    83:   Map existingTags = new HashMap();
    84:   for (int i = 0; i < ctx._source.tags.size(); i++) {
    85:     existingTags.put(ctx._source.tags[i].id, i);
    86:   }
    87: 
    88:   // Add or update tags
    89:   for (tag in params.document.add_tags) {
    90:     if (existingTags.containsKey(tag.id)) {
    91:       // Update existing tag
    92:       ctx._source.tags[existingTags.get(tag.id)] = tag;
    93:     } else {
    94:       // Add new tag
    95:       ctx._source.tags.add(tag);
    96:     }
    97:   }
    98: }
    99: 
    100: if (params.document.remove_tags != null && params.document.remove_tags.size() > 0) {
    101:   // Use traditional loop instead of removeIf for better compatibility
    102:   List tagsToKeep = new ArrayList();
    103:   for (int i = 0; i < ctx._source.tags.size(); i++) {
    104:     Map tag = ctx._source.tags[i];
    105:     String tagId = tag.get('id');
    106:     if (tagId != null && !params.document.remove_tags.contains(tagId)) {
    107:       tagsToKeep.add(tag);
    108:     }
    109:   }
    110:   ctx._source.tags = tagsToKeep;
    111: }