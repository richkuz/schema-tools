#!/usr/bin/env ruby

require 'json'
require 'net/http'
require 'uri'
require 'time'
require 'securerandom'

# Add the lib directory to the load path
$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))

require 'schema_tools/client'
require 'schema_tools/config'

class DataSeeder
  def initialize(index_name, count = 5000)
    @index_name = index_name
    @count = count
    @client = SchemaTools::Client.new(SchemaTools::Config.connection_url)
  end

  def seed!
    puts "üå± Seeding #{@count} documents into #{@index_name} index..."
    puts "üì° Connecting to: #{SchemaTools::Config.connection_url}"
    
    # Test connection
    unless @client.test_connection
      puts "‚ùå Failed to connect to OpenSearch/Elasticsearch"
      puts "Please ensure OPENSEARCH_URL or ELASTICSEARCH_URL is set correctly"
      exit 1
    end

    # Check if index exists
    unless @client.index_exists?(@index_name)
      puts "‚ùå Index #{@index_name} does not exist"
      puts "Please create the index first using: rake 'schema:migrate[#{@index_name}]'"
      exit 1
    end

    puts "‚úÖ Connection successful"
    puts "üìä Index #{@index_name} exists"
    
    # Generate and bulk insert data
    bulk_insert_data
  end

  private

  def bulk_insert_data
    batch_size = 1000
    total_batches = (@count.to_f / batch_size).ceil
    
    puts "üì¶ Inserting in #{total_batches} batches of #{batch_size} documents each"
    
    (0...total_batches).each do |batch_num|
      start_idx = batch_num * batch_size
      end_idx = [start_idx + batch_size, @count].min
      batch_count = end_idx - start_idx
      
      puts "üîÑ Processing batch #{batch_num + 1}/#{total_batches} (#{batch_count} documents)..."
      
      documents = generate_documents(start_idx, batch_count)
      bulk_insert_batch(documents)
      
      # Small delay between batches to avoid overwhelming the cluster
      sleep(0.1) if batch_num < total_batches - 1
    end
    
    puts "‚úÖ Successfully seeded #{@count} documents into #{@index_name}"
    puts "üîç You can now test your reindex operation!"
  end

  def generate_documents(start_idx, count)
    documents = []
    
    count.times do |i|
      doc_id = start_idx + i + 1
      documents << generate_product_document(doc_id)
    end
    
    documents
  end

  def generate_product_document(id)
    categories = [
      'Electronics', 'Clothing', 'Home & Garden', 'Sports & Outdoors', 
      'Books', 'Toys & Games', 'Health & Beauty', 'Automotive',
      'Food & Beverages', 'Office Supplies', 'Jewelry', 'Pet Supplies'
    ]
    
    brands = [
      'TechCorp', 'StyleBrand', 'HomePro', 'SportMax', 'BookWorld',
      'ToyLand', 'BeautyPlus', 'AutoTech', 'FoodFresh', 'OfficePro',
      'JewelCraft', 'PetCare'
    ]
    
    # Generate realistic product data
    category = categories.sample
    brand = brands.sample
    name = generate_product_name(category, brand)
    description = generate_description(name, category)
    price = generate_realistic_price(category)
    tags = generate_tags(category, brand)
    
    now = Time.now
    created_at = now - rand(365 * 24 * 60 * 60) # Random date within last year
    updated_at = created_at + rand(30 * 24 * 60 * 60) # Updated within 30 days of creation
    
    {
      id: "product_#{id}",
      name: name,
      description: description,
      price: price,
      category: category,
      tags: tags,
      created_at: created_at.iso8601,
      updated_at: updated_at.iso8601
    }
  end

  def generate_product_name(category, brand)
    product_types = {
      'Electronics' => ['Smartphone', 'Laptop', 'Tablet', 'Headphones', 'Speaker', 'Camera', 'Monitor', 'Keyboard'],
      'Clothing' => ['T-Shirt', 'Jeans', 'Dress', 'Jacket', 'Sneakers', 'Hat', 'Sweater', 'Shorts'],
      'Home & Garden' => ['Chair', 'Table', 'Lamp', 'Plant Pot', 'Garden Tool', 'Candle', 'Rug', 'Mirror'],
      'Sports & Outdoors' => ['Running Shoes', 'Bike', 'Tent', 'Backpack', 'Water Bottle', 'Yoga Mat', 'Dumbbells', 'Helmet'],
      'Books' => ['Novel', 'Textbook', 'Cookbook', 'Biography', 'Mystery', 'Romance', 'Sci-Fi', 'History'],
      'Toys & Games' => ['Action Figure', 'Board Game', 'Puzzle', 'Doll', 'Building Blocks', 'Video Game', 'Stuffed Animal', 'Art Set'],
      'Health & Beauty' => ['Shampoo', 'Moisturizer', 'Vitamins', 'Makeup', 'Skincare', 'Perfume', 'Hairbrush', 'Toothbrush'],
      'Automotive' => ['Tire', 'Oil Filter', 'Brake Pad', 'Car Battery', 'Air Filter', 'Spark Plug', 'Windshield Wiper', 'Floor Mat'],
      'Food & Beverages' => ['Coffee', 'Tea', 'Snacks', 'Cereal', 'Juice', 'Protein Bar', 'Spices', 'Chocolate'],
      'Office Supplies' => ['Pen', 'Notebook', 'Stapler', 'Paper Clips', 'Folder', 'Calculator', 'Desk Organizer', 'Whiteboard'],
      'Jewelry' => ['Necklace', 'Ring', 'Earrings', 'Bracelet', 'Watch', 'Pendant', 'Brooch', 'Anklet'],
      'Pet Supplies' => ['Dog Food', 'Cat Toy', 'Leash', 'Pet Bed', 'Fish Tank', 'Bird Cage', 'Pet Grooming Kit', 'Treats']
    }
    
    product_type = product_types[category]&.sample || 'Product'
    "#{brand} #{product_type} #{rand(1000..9999)}"
  end

  def generate_description(name, category)
    descriptions = {
      'Electronics' => [
        "High-quality #{name.downcase} with advanced features and modern design.",
        "Professional-grade #{name.downcase} perfect for everyday use.",
        "Innovative #{name.downcase} combining style and functionality.",
        "Premium #{name.downcase} engineered for superior performance."
      ],
      'Clothing' => [
        "Comfortable and stylish #{name.downcase} made from premium materials.",
        "Trendy #{name.downcase} designed for modern fashion enthusiasts.",
        "Durable #{name.downcase} that combines comfort with style.",
        "Classic #{name.downcase} that never goes out of fashion."
      ],
      'Home & Garden' => [
        "Beautiful #{name.downcase} that enhances your living space.",
        "Functional #{name.downcase} designed for modern homes.",
        "Elegant #{name.downcase} crafted with attention to detail.",
        "Versatile #{name.downcase} perfect for any room in your home."
      ],
      'Sports & Outdoors' => [
        "High-performance #{name.downcase} for active lifestyles.",
        "Durable #{name.downcase} built to withstand outdoor adventures.",
        "Professional #{name.downcase} designed for athletes.",
        "Reliable #{name.downcase} for all your sporting needs."
      ]
    }
    
    default_descriptions = [
      "Quality #{name.downcase} designed for everyday use.",
      "Premium #{name.downcase} that delivers exceptional value.",
      "Reliable #{name.downcase} built to last.",
      "Innovative #{name.downcase} for modern consumers."
    ]
    
    category_descriptions = descriptions[category] || default_descriptions
    category_descriptions.sample
  end

  def generate_realistic_price(category)
    price_ranges = {
      'Electronics' => [50, 2000],
      'Clothing' => [10, 300],
      'Home & Garden' => [20, 800],
      'Sports & Outdoors' => [25, 1500],
      'Books' => [5, 50],
      'Toys & Games' => [10, 200],
      'Health & Beauty' => [5, 150],
      'Automotive' => [15, 500],
      'Food & Beverages' => [2, 50],
      'Office Supplies' => [1, 100],
      'Jewelry' => [20, 2000],
      'Pet Supplies' => [5, 200]
    }
    
    min_price, max_price = price_ranges[category] || [10, 100]
    price = rand(min_price..max_price)
    
    # Round to realistic price points
    if price < 10
      price.round(2)
    elsif price < 100
      (price / 5).round * 5
    else
      (price / 10).round * 10
    end
  end

  def generate_tags(category, brand)
    base_tags = [category.downcase, brand.downcase]
    
    additional_tags = {
      'Electronics' => ['tech', 'digital', 'smart', 'wireless', 'bluetooth'],
      'Clothing' => ['fashion', 'casual', 'comfortable', 'stylish', 'trendy'],
      'Home & Garden' => ['decorative', 'functional', 'modern', 'classic', 'durable'],
      'Sports & Outdoors' => ['athletic', 'outdoor', 'fitness', 'adventure', 'performance'],
      'Books' => ['reading', 'educational', 'entertainment', 'fiction', 'non-fiction'],
      'Toys & Games' => ['fun', 'educational', 'creative', 'interactive', 'safe'],
      'Health & Beauty' => ['natural', 'organic', 'skincare', 'wellness', 'beauty'],
      'Automotive' => ['reliable', 'durable', 'performance', 'maintenance', 'quality'],
      'Food & Beverages' => ['organic', 'healthy', 'natural', 'fresh', 'premium'],
      'Office Supplies' => ['professional', 'efficient', 'organized', 'productive', 'quality'],
      'Jewelry' => ['elegant', 'luxury', 'fashionable', 'precious', 'beautiful'],
      'Pet Supplies' => ['safe', 'healthy', 'comfortable', 'durable', 'pet-friendly']
    }
    
    category_tags = additional_tags[category] || ['quality', 'premium', 'reliable']
    base_tags + category_tags.sample(2)
  end

  def bulk_insert_batch(documents)
    bulk_body = []
    
    documents.each do |doc|
      # Index action metadata
      bulk_body << {
        index: {
          _index: @index_name,
          _id: doc[:id]
        }
      }
      # Document data
      bulk_body << doc
    end
    
    # Convert to NDJSON format
    ndjson = bulk_body.map { |line| JSON.generate(line) }.join("\n") + "\n"
    
    # Send bulk request
    uri = URI("#{SchemaTools::Config.connection_url}/_bulk")
    request = Net::HTTP::Post.new(uri)
    request['Content-Type'] = 'application/x-ndjson'
    request.body = ndjson
    
    response = Net::HTTP.start(uri.hostname, uri.port) { |http| http.request(request) }
    
    unless response.code.to_i.between?(200, 299)
      puts "‚ùå Bulk insert failed: HTTP #{response.code}"
      puts "Response: #{response.body}"
      exit 1
    end
    
    result = JSON.parse(response.body)
    
    # Check for errors in the response
    if result['errors']
      error_count = result['items'].count { |item| item['index']['status'] >= 400 }
      if error_count > 0
        puts "‚ö†Ô∏è  #{error_count} documents failed to index"
        # Show first few errors for debugging
        result['items'].first(5).each do |item|
          if item['index']['status'] >= 400
            puts "   Error: #{item['index']['error']}"
          end
        end
      end
    end
  end
end

# Main execution
if ARGV.length < 1
  puts "Usage: ./bin/seed_data <index_name> [count]"
  puts ""
  puts "Examples:"
  puts "  ./bin/seed_data products-1"
  puts "  ./bin/seed_data products-1 10000"
  puts ""
  puts "Environment variables:"
  puts "  OPENSEARCH_URL or ELASTICSEARCH_URL - Connection URL (required)"
  exit 1
end

index_name = ARGV[0]
count = ARGV[1]&.to_i || 5000

if count <= 0
  puts "‚ùå Count must be a positive number"
  exit 1
end

seeder = DataSeeder.new(index_name, count)
seeder.seed!